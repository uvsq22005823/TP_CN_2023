mail prof : jgurhem@aneo.fr

1) D'après https://netlib.org/clapack/readme
double *A;
A = malloc( LDA*N*sizeof(double) );

# Note that for best memory utilization, you would set LDA=M, the
# actual number of rows of A.  If you now wish to operate on the
# matrix A, remember that A is in column-major order.
M taille colonne
N taille ligne


2) Indique que la matrice est stockée en column-major.
https://www.netlib.org/lapack/lapacke.html#_array_arguments


3) On stocke la matrice dans un tableau à 1 dimension ;
la dimension principale est la taille de la dimension principale
i.e. si row-major -> taille row (nombre column) / si column-major -> taille column (nombre ligne)
https://www.netlib.org/lapack/lapacke.html#_array_arguments


POUR LA DOC DES FONCTIONS => http://www.netlib.org/lapack/explore-html/

4)
subroutine 	dgbmv (trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy)
https://www.netlib.org/lapack/explore-html/d2/d3f/dgbmv_8f.html

subroutine dgbmv  (     character                             trans,
                        integer                               m,
                        integer                               n,
                        integer                               kl,
                        integer                               ku,
                        double precision                      alpha,
                        double precision, dimension(lda,*)    a,
                        integer                               lda,
                        double precision, dimension(*)        x,
                        integer                               incx,
                        double precision                      beta,
                        double precision, dimension(*)        y,
                        integer                               incy
)
https://www.netlib.org/lapack/explore-html/dd/df4/group__gbmv_ga7001c2a185bcc8a3b6731f5d1ea7093e.html#ga7001c2a185bcc8a3b6731f5d1ea7093e

*> DGBMV  performs one of the matrix-vector operations
*>
*>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
*>
*> where alpha and beta are scalars, x and y are vectors and A is an
*> m by n band matrix, with kl sub-diagonals and ku super-diagonals.
https://netlib.org/blas/dgbmv.f



5)
subroutine dgbmv 	( 	character  	trans,
		integer  	m,
		integer  	n,
		integer  	kl,
		integer  	ku,
		double precision  	alpha,
		double precision, dimension(lda,*)  	a,
		integer  	lda,
		double precision, dimension(*)  	x,
		integer  	incx,
		double precision  	beta,
		double precision, dimension(*)  	y,
		integer  	incy
	)

 DGBMV  performs one of the matrix-vector operations

    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,

 where alpha and beta are scalars, x and y are vectors and A is an
 m by n band matrix, with kl sub-diagonals and ku super-diagonals.

https://www.netlib.org/lapack/explore-html/dd/df4/group__gbmv_ga7001c2a185bcc8a3b6731f5d1ea7093e.html#ga7001c2a185bcc8a3b6731f5d1ea7093e



6)
subroutine dgbtrs 	( 	character  	trans,
		integer  	n,
		integer  	kl,
		integer  	ku,
		integer  	nrhs,
		double precision, dimension( ldab, * )  	ab,
		integer  	ldab,
		integer, dimension( * )  	ipiv,
		double precision, dimension( ldb, * )  	b,
		integer  	ldb,
		integer  	info
	)

	 DGBTRS solves a system of linear equations
    A * X = B  or  A**T * X = B
 with a general band matrix A using the LU factorization computed
 by DGBTRF.

 https://www.netlib.org/lapack/explore-html/d1/dd7/group__gbtrs_ga21ed607226c9690cadc991f15435fa74.html#ga21ed607226c9690cadc991f15435fa74


 7)
 subroutine dgbsv 	( 	integer  	n,
		integer  	kl,
		integer  	ku,
		integer  	nrhs,
		double precision, dimension( ldab, * )  	ab,
		integer  	ldab,
		integer, dimension( * )  	ipiv,
		double precision, dimension( ldb, * )  	b,
		integer  	ldb,
		integer  	info
	)

 DGBSV computes the solution to a real system of linear equations
 A * X = B, where A is a band matrix of order N with KL subdiagonals
 and KU superdiagonals, and X and B are N-by-NRHS matrices.

 The LU decomposition with partial pivoting and row interchanges is
 used to factor A as A = L * U, where L is a product of permutation
 and unit lower triangular matrices with KL subdiagonals, and U is
 upper triangular with KL+KU superdiagonals.  The factored form of A
 is then used to solve the system of equations A * X = B.

 https://www.netlib.org/lapack/explore-html/db/df8/group__gbsv_gaff55317eb3aed2278a85919a488fec07.html#gaff55317eb3aed2278a85919a488fec07


8) résidu relatif arrière :
   résidu r = b - Ax (x^)
   => résidu relatif arrière relres = ||r|| / ||A||||x|| (x^)
   MAIS on normalise ici par ||b||
      => ||r|| / ||b||

Fonction dnrm2( 	integer  	n,
		real(wp), dimension(*)  	x,
		integer  	incx
	)

	pour calculer la norme 2 d'un vecteur
